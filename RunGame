import math
import time

class TicTacToe:
    #Makes a 3 by 3 board on which the game will be played on
    #A space with value 0 is unclaimed, marked with 1 is for player 1, and 2 for player 2
    def __init__(self):
        self.board = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] #creates 3 by 3 empty board   (Data collection type #1 List)

    def clearBoard(self):
        self.board = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] #resets board 

    def addValue(self, xPos: int, yPos: int, playerNum):
        if self.board[xPos][yPos] != 0: #checks if the square has already been claimed
            #print("Square has already been claimed, try again!")
            return False #allows player to reselect square when playing a game        (Data type#2 Boolean (T/F)
        else:
            self.board[xPos][yPos] = playerNum #square is claimed by player
            return True

    #functions is to make checking for wins easy, private method so this should not be called outside of this class
    def __checkValuesForWin(self, val1: int, val2: int, val3: int): #double underscore before the name to make it hard to call this function outside of this class defintion
        return val1 == val2 == val3 and val1 != 0

    def checkForWin(self):
        #checks for wins along rows
        for curRow in self.board: #iterates through each row
            if self.__checkValuesForWin(curRow[0], curRow[1], curRow[2]): #checks if all values in the row are the same
                return curRow[0] #returns the number of the player who has won the game
    
        #checks for wins along columns
        for curCol in range(3): #iterates through each column
            if self.__checkValuesForWin(self.board[0][curCol], self.board[1][curCol], self.board[2][curCol]):
                return self.board[0][curCol] #returns the number of the player who has won the game
      
        #checks for wins along diagonals
        if self.__checkValuesForWin(self.board[0][0], self.board[1][1], self.board[2][2]): #diagonal 1
            return self.board[0][0] #returns the number of the player who has won the game
        if self.__checkValuesForWin(self.board[0][2], self.board[1][1], self.board[2][0]): #diagonal 2
            return self.board[0][2] #returns the number of the player who has won the game

    def isFull(self):
        isFull = True #default value to true
        for row in self.board: #checks all squares for value of 0, which would indicate that the board is not full
            for cell in row: #Nested Loop
                if cell == 0: #Selection Statement
                    isFull = False
                    break
            if not isFull: #second break so the loop does not continue unnecisarilly
                break
        return isFull

    def printBoard(self):
        symbols = {0: '.', 1: 'X', 2: 'O'} #creates dictionary to convert board values to prinable icons (0, 1, 2 -> ., X, O)
        print("\nCurrent board:")
        for row in self.board:
            print(" ".join(symbols[cell] for cell in row))
        print('') #skips line

    def returnBoard(self):
        return self.board


class GameMode:

    symbols = {0: '.', 1: 'X', 2: 'O'} #creates dictionary to convert board values to prinable icons (0, 1, 2 -> ., X, O)
    waitTime = 4
    '''
    def playGame(self):
        game = TicTacToe()
        currentPlayer = 1

        while True:
            game.printBoard()
            print(f"Player {currentPlayer}'s turn (X if 1, O if 2).")

            try: #try statement for proper and improper inputs. Loops until a valid input is entered.
                xPos = int(input("Enter row (0-2): "))
                yPos = int(input("Enter column (0-2): "))
                if xPos < 0 or xPos > 2 or yPos < 0 or yPos > 2:
                    print("Invalid input! Row and column must be between 0 and 2.") #detects if input is out of range and tells player
                    continue
            except ValueError:
                print("Invalid input! Please enter integers.")
                continue

            if not game.addValue(xPos, yPos, currentPlayer): #adds the player input to the board. if the square already has a value, the player is told to retry
                print("Square has already been claimed, try again!")
                continue #(Data Collection Type #3 Tuple^)

            winner = game.checkForWin()
            if winner == 1 or winner == 2:
                game.printBoard()
                print(f"Player {winner} wins!") #identifies higher value to assign winner and returns result
                break
            elif game.isFull():
                game.printBoard() #calling printBorard function to show the game board
                print("It's a tie!")
                break

            currentPlayer += 1
            if currentPlayer >= 3: #eliminates possible weirdness if value is over 3 (but gives player 1 an advantage :) ?
                currentPlayer = 1
    '''
    def playGameOntoFile(self, startLine: int):
        game = TicTacToe()
        game.clearBoard()
        currentPlayer = 1
        userFile = open("TicTacToe.txt", "r+") #r+ so it does not delete contents of file but adds to them instead

        while True:
            #this block of code is meant to only start printing onto the specified line and below. This is to future proof the program
            userFile.flush() #flush to make sure file it updated
            userFile.seek(0) #seek command is used to move the position of cursor within a file to specify where to read or write data. This sets cursor to position 0.
            for curLine in range(startLine): #skips to the specified start line
                userFile.readline()
            userFile.truncate() #deletes all data after the cursor

            userFile.write("Current board:\n")
            for row in game.returnBoard(): #prints the board onto the file
                userFile.write(" ".join(self.symbols[cell] for cell in row) + '\n')

            userFile.write(f"Player {self.symbols[currentPlayer]}'s turn.\nEnter your move: ")

            #while loop to check for user inputs on the file
            while True:
                userFile.flush() #flush to make sure file is updated
                userFile.seek(0, 2) #sets cursor to end of the file
                userFile.seek(userFile.tell() - 1)
                if userFile.read(1) == '\n': #checks if last value is enter key
                    break
                time.sleep(0.1)
            try:
                userFile.seek(0, 2)
                userFile.seek(userFile.tell() - 4) #goes to 4 values before end of file, 4 because there is "00\r\n" for example
                xPos = int(userFile.read(1))
                yPos = int(userFile.read(1))
                if xPos < 0 or xPos > 2 or yPos < 0 or yPos > 2: #detects if input is out of range and tells player
                    userFile.seek(0, 2)
                    userFile.write("Invalid input! Row and column must be between 0 and 2.")
                    time.sleep(self.waitTime) #lets user read message before moving on 
                    continue #skips rest of loop to restart process
            except ValueError:
                userFile.seek(0, 2)
                userFile.write("Invalid input! Please enter integers.")
                time.sleep(self.waitTime) #lets user read message before moving on 
                continue #skips rest of loop to restart process

            if not game.addValue(xPos, yPos, currentPlayer): #adds the player input to the board. if the square already has a value, the player is told to retry
                userFile.write("Square has already been claimed, try again!")
                userFile.flush()
                time.sleep(self.waitTime) #lets user read message before moving on 
                continue #skips rest of loop to restart process

            #block to check and output winner
            winner = game.checkForWin() #output is the player number who has won, or 0 if there is no winner
            if winner == 1 or winner == 2:
                userFile.write(f"Player {self.symbols[currentPlayer]} wins!")
                break
            elif game.isFull():
                userFile.write("It's a tie!")
                break
            #no else statement because if neither of these conditions are True, the game has not finished yet

            currentPlayer += 1
            if currentPlayer >= 3: #eliminates possible weirdness if value is over 3 (but gives player 1 an advantage :)
                currentPlayer = 1
                
        #prints finals board after game has finished.
        userFile.seek(0)
        for curLine in range(startLine):
            userFile.readline()
        userFile.seek(userFile.tell())
        userFile.write("Current board:\n")
        for row in game.returnBoard():
            userFile.write(" ".join(self.symbols[cell] for cell in row) + '\n')



if __name__ == "__main__":
    gamez = GameMode()
    gamez.playGameOntoFile(0)
