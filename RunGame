import math
import time

class TicTacToe:
    #Makes a 3 by 3 board on which the game will be played on
    #A space with value 0 is unclaimed, marked with 1 is for player 1, and 2 for player 2
    def __init__(self):
        self.board = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] #creates 3 by 3 empty board   (Data collection type #1 List)

    def clearBoard(self): #______THIS METHOD IS NOT USED IN THE OPERATION OF THE GAME___________
        self.board = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] #resets board 

    def addValue(self, xPos: int, yPos: int, playerNum):
        if self.board[xPos][yPos] != 0: #checks if the square has already been claimed
            #print("Square has already been claimed, try again!")
            return False #allows player to reselect square when playing a game        (Data type#2 Boolean (T/F)
        else:
            self.board[xPos][yPos] = playerNum #square is claimed by player
            return True

    #functions is to make checking for wins easy, private method so this should not be called outside of this class
    def __checkValuesForWin(self, val1: int, val2: int, val3: int): #double underscore before the name to make it hard to call this function outside of this class defintion
        return val1 == val2 == val3 and val1 != 0

    def checkForWin(self):
        #checks for wins along rows
        for curRow in self.board: #iterates through each row
            if self.__checkValuesForWin(curRow[0], curRow[1], curRow[2]): #checks if all values in the row are the same
                return curRow[0] #returns the number of the player who has won the game
    
        #checks for wins along columns
        for curCol in range(3): #iterates through each column
            if self.__checkValuesForWin(self.board[0][curCol], self.board[1][curCol], self.board[2][curCol]):
                return self.board[0][curCol] #returns the number of the player who has won the game
      
        #checks for wins along diagonals
        if self.__checkValuesForWin(self.board[0][0], self.board[1][1], self.board[2][2]): #diagonal 1
            return self.board[0][0] #returns the number of the player who has won the game
        if self.__checkValuesForWin(self.board[0][2], self.board[1][1], self.board[2][0]): #diagonal 2
            return self.board[0][2] #returns the number of the player who has won the game

    def isFull(self):
        isFull = True #default value to true
        for row in self.board: #checks all squares for value of 0, which would indicate that the board is not full
            for cell in row: #Nested Loop
                if cell == 0: #Selection Statement
                    isFull = False
                    break
            if not isFull: #second break so the loop does not continue unnecisarilly
                break
        return isFull

    def printBoard(self):
        symbols = {0: '.', 1: 'X', 2: 'O'} #creates dictionary to convert board values to prinable icons (0, 1, 2 -> ., X, O)
        print("\nCurrent board:")
        for row in self.board:
            print(" ".join(symbols[cell] for cell in row))
        print('') #skips line

    def returnBoard(self):
        return self.board


class GameMode:

    symbols = {0: '.', 1: 'X', 2: 'O'} #creates dictionary to convert board values to prinable icons (0, 1, 2 -> ., X, O)
    waitTime = 4

    def playGame(self):
        game = TicTacToe()
        currentPlayer = 1

        while True:
            game.printBoard()
            print(f"Player {currentPlayer}'s turn (X if 1, O if 2).")

            try: #try statement for proper and improper inputs
                xPos = int(input("Enter row (0-2): "))
                yPos = int(input("Enter column (0-2): "))
                if xPos < 0 or xPos > 2 or yPos < 0 or yPos > 2:
                    print("Invalid input! Row and column must be between 0 and 2.") #detects if input is out of range and tells player
                    continue
            except ValueError:
                print("Invalid input! Please enter integers.")
                continue

            if not game.addValue(xPos, yPos, currentPlayer): #adds the player input to the board. if the square already has a value, the player is told to retry
                print("Square has already been claimed, try again!")
                continue #(Data Collection Type #3 Tuple^)

            winner = game.checkForWin()
            if winner == 1 or winner == 2:
                game.printBoard()
                print(f"Player {winner} wins!")
                break
            elif game.isFull():
                game.printBoard() #calling printBorard function to show the game board
                print("It's a tie!")
                break

            currentPlayer += 1
            if currentPlayer >= 3: #eliminates possible weirdness if value is over 3 (but gives player 1 and advantage :)
                currentPlayer = 1

    def playGameOntoFile(self, startLine: int):
        game = TicTacToe()
        game.clearBoard()
        currentPlayer = 1
        userFile = open("TicTacToe.txt", "r+")

        while True:
            userFile.seek(0)
            for curLine in range(startLine):
                userFile.readline()
            userFile.seek(userFile.tell())
            userFile.truncate()

            userFile.write("Current board:\n")
            for row in game.returnBoard():
                userFile.write(" ".join(self.symbols[cell] for cell in row) + '\n')
            
            userFile.write(f"Player {self.symbols[currentPlayer]}'s turn.\n")
            userFile.write('Enter your move: ')
            cursorPos = userFile.tell()

            while True:
                userFile.flush()
                userFile.seek(0, 2)
                userFile.seek(userFile.tell() - 1)
                if userFile.read(1) == '\n':
                    break
                time.sleep(0.1)
            try:
                userFile.seek(0, 2)
                userFile.seek(userFile.tell() - 4)
                xPos = int(userFile.read(1))
                yPos = int(userFile.read(1))
                if xPos < 0 or xPos > 2 or yPos < 0 or yPos > 2: #detects if input is out of range and tells player
                    userFile.seek(0, 2)
                    userFile.write("Invalid input! Row and column must be between 0 and 2.")
                    userFile.flush()
                    time.sleep(self.waitTime)
                    continue
            except ValueError:
                userFile.seek(0, 2)
                userFile.write("Invalid input! Please enter integers.")
                userFile.flush()
                time.sleep(self.waitTime)
                continue

            if not game.addValue(xPos, yPos, currentPlayer): #adds the player input to the board. if the square already has a value, the player is told to retry
                userFile.write("Square has already been claimed, try again!")
                userFile.flush()
                time.sleep(self.waitTime)
                continue #(Data Collection Type #3 Tuple^)

            winner = game.checkForWin()
            if winner == 1 or winner == 2:
                game.printBoard()
                userFile.write(f"Player {self.symbols[currentPlayer]} wins!")
                break
            elif game.isFull():
                game.printBoard() #calling printBorard function to show the game board
                userFile.write("It's a tie!")
                break

            currentPlayer += 1
            if currentPlayer >= 3: #eliminates possible weirdness if value is over 3 (but gives player 1 and advantage :)
                currentPlayer = 1

    def playGames(self, numGames: int):
        #Add code here
        None

    def playUntilWin(self):
        #code here
        None


if __name__ == "__main__":
    gamez = GameMode()
    gamez.playGameOntoFile(0)
    #gamez.playGame()#Calling the playGame function

#I/O File Section: This code does not take data from a file nor does it save to another file.
