import math
import time
'''
This game runs fully on the TicTacToe.txt and not the terminal. To get this to work you must save the file after you write your inputs.
We took this approach as we wanted the inputs and the outputs on the area, instead of inputting on the terminal and then writing on the file.
This approach came with some weirdness regarding the way file updates are handled in code, and attempting to run user inputs and the same synchronously
'''

class TicTacToe:
    #Makes a 3 by 3 board on which the game will be played on
    #A space with value 0 is unclaimed, marked with 1 is for player 1, and 2 for player 2
    def __init__(self):
        self.board = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] #creates 3 by 3 empty board   (Data collection type #1 List)

    def clearBoard(self):
        self.board = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] #resets board 

    def addValue(self, xPos: int, yPos: int, playerNum):
        if self.board[xPos][yPos] != 0: #checks if the square has already been claimed
            #print("Square has already been claimed, try again!")
            return False #allows player to reselect square when playing a game        (Data type#2 Boolean (T/F)
        else:
            self.board[xPos][yPos] = playerNum #square is claimed by player
            return True

    #functions is to make checking for wins easy, private method so this should not be called outside of this class
    def __checkValuesForWin(self, val1: int, val2: int, val3: int): #double underscore before the name to make it hard to call this function outside of this class defintion
        return val1 == val2 == val3 and val1 != 0

    def checkForWin(self):
        #checks for wins along rows
        for curRow in self.board: #iterates through each row
            if self.__checkValuesForWin(curRow[0], curRow[1], curRow[2]): #checks if all values in the row are the same
                return curRow[0] #returns the number of the player who has won the game
    
        #checks for wins along columns
        for curCol in range(3): #iterates through each column
            if self.__checkValuesForWin(self.board[0][curCol], self.board[1][curCol], self.board[2][curCol]):
                return self.board[0][curCol] #returns the number of the player who has won the game
      
        #checks for wins along diagonals
        if self.__checkValuesForWin(self.board[0][0], self.board[1][1], self.board[2][2]): #diagonal 1
            return self.board[0][0] #returns the number of the player who has won the game
        if self.__checkValuesForWin(self.board[0][2], self.board[1][1], self.board[2][0]): #diagonal 2
            return self.board[0][2] #returns the number of the player who has won the game

    def isFull(self):
        isFull = True #default value to true
        for row in self.board: #checks all squares for value of 0, which would indicate that the board is not full
            for cell in row: #Nested Loop
                if cell == 0: #Selection Statement
                    isFull = False
                    break
            if not isFull: #second break so the loop does not continue unnecessarily
                break
        return isFull

    def printBoard(self):
        symbols = {0: '.', 1: 'X', 2: 'O'} #creates dictionary to convert board values to prinable icons (0, 1, 2 -> ., X, O)
        print("\nCurrent board:")
        for row in self.board:
            print(" ".join(symbols[cell] for cell in row))
        print('') #skips line

    def returnBoard(self):
        return self.board


class GameMode:

    symbols = {0: '.', 1: 'X', 2: 'O'} #creates dictionary to convert board values to prinable icons (0, 1, 2 -> ., X, O)
    waitTime = 4
    '''
    def playGame(self):
        game = TicTacToe()
        currentPlayer = 1

        while True:
            game.printBoard()
            print(f"Player {currentPlayer}'s turn (X if 1, O if 2).")

            try: #try statement for proper and improper inputs. Loops until a valid input is entered.
                xPos = int(input("Enter row (0-2): "))
                yPos = int(input("Enter column (0-2): "))
                if xPos < 0 or xPos > 2 or yPos < 0 or yPos > 2:
                    print("Invalid input! Row and column must be between 0 and 2.") #detects if input is out of range and tells player
                    continue
            except ValueError:
                print("Invalid input! Please enter integers.")
                continue

            if not game.addValue(xPos, yPos, currentPlayer): #adds the player input to the board. if the square already has a value, the player is told to retry
                print("Square has already been claimed, try again!")
                continue #(Data Collection Type #3 Tuple^)

            winner = game.checkForWin()
            if winner == 1 or winner == 2:
                game.printBoard()
                print(f"Player {winner} wins!") #identifies higher value to assign winner and returns result
                break
            elif game.isFull():
                game.printBoard() #calling printBorard function to show the game board
                print("It's a tie!")
                break

            currentPlayer += 1
            if currentPlayer >= 3: #eliminates possible weirdness if value is over 3 (but gives player 1 an advantage :) ?
                currentPlayer = 1
    '''
    def playGameOntoFile(self, startLine: int):
        game = TicTacToe()
        game.clearBoard()
        currentPlayer = 1
        userFile = open("TicTacToe.txt", "r+") #r+ so it does not delete contents of file but adds to them instead

        userFile.seek(0) #seek command is used to move the position of cursor within a file to specify where to read or write data. This sets cursor to position 0.
        for _ in range(startLine): #skips to the specified start line
            userFile.readline()
        truncatePos = userFile.tell() #sets known truncate point for this game

        while True:
            #this block of code is meant to only start printing onto the specified line and below. This is to future proof the program
            userFile.flush() #flush to make sure file it updated
            userFile.seek(truncatePos)
            userFile.truncate() #deletes all data after the cursor

            userFile.write("Current board:\n")
            for row in game.returnBoard(): #prints the board onto the file
                userFile.write(" ".join(self.symbols[cell] for cell in row) + '\n')

            userFile.write(f"Player {self.symbols[currentPlayer]}'s turn.\nEnter your move: ")

            #while loop to check for user inputs on the file
            while True:
                userFile.flush() #flush to make sure file is updated
                time.sleep(0.1)
                userFile.seek(0, 2) #sets cursor to end of the file

                if userFile.tell() >= 1: #weird error where file will read as empty, so this checks to make sure the file has content to proceed
                    userFile.seek(userFile.tell() - 1)
                    if userFile.read(1) == '\n': #checks if last value is enter key
                        break
            try:
                userFile.seek(0, 2)
                userFile.seek(userFile.tell() - 4) #goes to 4 values before end of file, 4 because there is "00\r\n" for example
                xPos = int(userFile.read(1))
                yPos = int(userFile.read(1))
                if xPos < 0 or xPos > 2 or yPos < 0 or yPos > 2: #detects if input is out of range and tells player
                    userFile.seek(0, 2)
                    userFile.write("Invalid input! Row and column must be between 0 and 2.")
                    userFile.flush()
                    time.sleep(self.waitTime) #lets user read message before moving on 
                    continue #skips rest of loop to restart process
            except (ValueError, SyntaxError):
                userFile.seek(0, 2)
                userFile.write("Invalid input! Please enter integers.")
                userFile.flush()
                time.sleep(self.waitTime) #lets user read message before moving on 
                continue #skips rest of loop to restart process

            if not game.addValue(xPos, yPos, currentPlayer): #adds the player input to the board. if the square already has a value, the player is told to retry
                userFile.write("Square has already been claimed, try again!")
                userFile.flush()
                time.sleep(self.waitTime) #lets user read message before moving on 
                continue #skips rest of loop to restart process

            #block to check and output winner
            winner = game.checkForWin() #output is the player number who has won, or 0 if there is no winner
            if winner == 1 or winner == 2 or game.isFull(): #ends game if someone has won, or if the game is full
                break

            currentPlayer += 1
            if currentPlayer > 2: #eliminates possible weirdness if value is over 2 (but gives player 1 an advantage :)
                currentPlayer = 1
                
        #prints finals board after game has finished.
        userFile.seek(truncatePos)
        userFile.truncate() #deletes all data after the cursor
        userFile.write("Current board:\n")
        for row in game.returnBoard():
            userFile.write(" ".join(self.symbols[cell] for cell in row) + '\n')
            
        #writes the winner or if it is a tie
        if winner == 1 or winner == 2:
                userFile.write(f"Player {self.symbols[currentPlayer]} wins!")
        elif game.isFull():
            userFile.write("It's a tie!")



if __name__ == "__main__":
    gamez = GameMode()
    userFile = open("TicTacToe.txt", "w")
    userFile.write('This is a TicTacToe game.\nAll inputs should be done on this file, not the terminal.\nWhen inputting values, click the end of the very last line and then write your values.\nYour values should be written in the form row-column like "00" where the first number is the row numnber, in the range of 0-2, and the sceond is the column.\nAfter you have typed your input, click "Enter" and then save the file (Ctrl/Command + S).\nHave fun and don\'t cheat!\n\n')
    userFile.seek(0, 0)
    userFile.close()
    gamez.playGameOntoFile(8)
